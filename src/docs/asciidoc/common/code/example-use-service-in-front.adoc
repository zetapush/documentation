:relative-path: ../../
include::{docdir}/variables.adoc[]

In our example we use this _custom cloud service_ named `HelloService`:

.worker/index.ts
[source,typescript,linenumbers]
----
export default class HelloService {       <1>
  hello() {                               <2>
    return `Hello World`;                 <3>
  }
}
----
<1> The service is exported in roder to be instantiated by ZetaPush _CLI_
<2> A _custom cloud function_ name `hello` is defined in this _custom cloud service_.
<3> The _custom cloud function_ simply returns a message. You can write any code you want here.

[TIP]
====
A _custom cloud service_ can have as many _custom cloud functions_ as you want.

A _custom cloud function_ can have as many parameters as you want.

A _custom cloud function_ can return anything including a link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise[Promise]. 
You can also write your code using link:https://javascript.info/async-await[async/await syntax].
====

Now we create the HTML page with a button to display the _HelloWorld_ message in the console:

.front/index.html
[source, html, linenumbers]
----
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Celtia</title>
</head>

<body>
    <button onclick="hello()">hello</button> <1>
    <ul></ul>

    <script src="https://unpkg.com/@zetapush/client"></script> <2>
    <script src="./index.js"></script>
</body>

</html>
----
<1> We call `hello()`, which in turns calls our _custom cloud service_
<2> Dependency to ZetaPush Core

Finally, we have the front-side code call our services:

.front/index.js
[source, javascript, linenumbers]
----
// Create new ZetaPush Client
const client = new ZetaPushClient.WeakClient();     // <1>
// Create a proxy to invoked worker methods
const api = client.createProxyTaskService();        // <2>
// Handle connection
client.connect().then(() => (                       // <3>
  console.debug('onConnectionEstablished'),
  [...document.querySelectorAll('button')].forEach((node) =>
    node.removeAttribute('disabled'),
  )
));
// Handle DOM events
document.querySelector('.js-Hello').addEventListener('click', async () => {
  console.log(await api.hello());                   // <4>
});
----
<1> Create the ZetaPush client (using automatic injection of `appName`)
<2> API to access our custom service(s)
<3> Connection to the ZetaPush platform
<4> Call our _cloud function_ and display the result

*Now when we click the button, "Hello World" is displayed on the page.*


.How it works ?
[plantuml, call-zetapush-cloud-service, png, role="center"]     
....
participant client order 10
participant "ZetaPush cloud" order 20
participant worker order 30
participant "custom cloud service" order 40

box "Initialization"
  autonumber
  worker --> "ZetaPush cloud" : Establish connection
  "ZetaPush cloud" --> worker : connection established

  client --> "ZetaPush cloud" : Establish connection
  "ZetaPush cloud" --> client : connection established
end box

client --> "ZetaPush cloud" : send message to call 'hello' in worker
"ZetaPush cloud" --> worker : send message to call 'hello'
worker -> "custom cloud service" : hello()
"custom cloud service" -\ worker : "Hello World"
worker --> "ZetaPush cloud" : send message "Hello World"
"ZetaPush cloud" --> client : send message "Hello World"
client -> client : display message
....

When you start your project locally, the first thing that happens is that your worker connects himself automatically to the ZetaPush cloud [1][2].

Then when you open your web browser, the connection from the client is established between the web page and the ZetaPush cloud [3][4].

When you click on the button, a message is sent through the opened connection in order to tell ZetaPush cloud to execute some
remote code [5]. ZetaPush cloud routes the message to your worker [6] (that is running on your machine here). The worker receives the message
and calls the `hello` _cloud function_ [7].

The _cloud function_ generates a result [8]. The worker picks this result and transform it to a message [9]. This message is then sent
to the ZetaPush cloud [10]. The ZetaPush cloud routes the response message to the calling client [11]. The client receives the message
and the response is parsed [12] and available in your JavaScript.